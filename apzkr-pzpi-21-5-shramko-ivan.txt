РЕФЕРАТ

Пояснювальна записка до курсової роботи: 80 с., 26 рис., 12 джерел.
АВТОМАТИЗАЦІЯ, КЕРУВАННЯ НАВЧАННЯМ, ВИКОРИСТАННЯ ДРОНІВ, ТРЕНУВАЛЬНА ПРОГРАМА, АДМІНІСТРУВАННЯ, ПРИСТРОЇ ФІКСАЦІЇ ПРОХОДЖЕННЯ, АРХІТЕКТУРА, ПРОГРАМНА СИСТЕМА.
Метою роботи є розробка програмної системи для автоматизації проведення тренувань та змагань з використанням дронів.
Методи розробки базуються на використанні середовища розробки Microsoft Visual Studio 2022, платформ та бібліотек .NET 8, ADO.NET, ASP.NET Core, .NET MAUI, Angular 13, хмарного середовища AZURE, мов програмування C#, TypeScript, C/C++, HTML, CSS, пристроїв Arduino Wemos D1 та датчика для зчитування міток MFRC522.
В результаті розоблена програмна система, що автоматизує процес проведення практичних навчань в польових умовах, робить їх більш ефективними. Актуальність системи полягає в тому що, на даний час попри активне використання безпілотних систем в багатьох сферах суспільного життя та промисловості, а також військовій сфері, програмні продукти для ефективного та злагодженого процесу підготовки пілотів активно не використовуються через малу кількість подібних систем та неповну відповідність даних систем потребам користувачів через відносно недавнє зародження даної галузі.
Програмна система вирішує визначену проблему користувачів: відсутність єдиної системи для управлінням проведення навчань та змагань, що дає можливість відслідковування результатів навчання та підготовки пілотів для дронів.

ЗМІСТ

Вступ……………………………………………………………………..7
1 Аналіз предметної області…………………………………………....8
2 Концепція рішення та рамки первинного випуску………………...12
3 Проектування, архітектура та реалізація серверної частини системи………………………………………………………………….17
4 Проектування, архітектура та реалізація частини IoT застосунку системи………………………………………………………………….39
5 Проектування, архітектура та реалізація клієнтської частини системи……………………………………………………………….…49
6 Проектування, архітектура та реалізація частини мобільного застосунку………………………………………………………………61
Висновки……………………………………………………………..…69
Перелік джерел посилання…………………………………………….70
Додаток А…………………………………………………………….…71
Додаток Б……………………………………………………………….72
Додаток В…………………………………………………………….…74
Додаток Г…………………………………………………………….…76
Додаток Д…………………………………………………………….....77
Додаток Е……………………………………………………………….78
Додаток Ж………………………………………………………………79
Додаток И…………………………………………………………….…80

ВСТУП

Мета та ідея програмної системи - створити систему, що автоматизує процес проведення практичних навчань в польових умовах, робить їх більш ефективними, стимулює до популяризації використання дронів у різних сферах життя за рахунок систематизованої та ефективної підготовки. 
Для визначення основних функцій програмної системи було проведено бізнес-аналіз предметної області, проведено порівняльний аналіз конкурентів, сформовано основні критерії до програмної системи, визначено головні проблеми користувачів.
Програмна система складається з декількох частин: серверна частина, клієнтський застосунок, IoT пристрій, мобільний додаток. Перед початком розробки, спираючись на основні вимоги та призначення системи визначено архітектуру її складових, відповідні рішення задокументовано за допомогою відповідних UML діаграм.
Під час розробки програмної системи, враховувалися вимоги щодо забезпечення безпеки користувацьких даних, використання безпечних протоколів взаємодії, механізмів авторизації та аутентифікації, забезпечення функцій адміністрування, створення резервних копій, забезпечення локалізації та інтернаціоналізації, роботи з датами та часом, використання ефективних методів обробки користувацьких даних, відповідні рішення задокументовано за допомогою відповідних UML діаграм та прикладів фрагментів програмного коду.

1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ

1.1 Передумови
В останні декілька років безпілотні літальні апарати (дрони) активно використовуються у багатьох сферах: військова, аграрна, охорона та нагляд за територією, відеоспостереження, знімання репортажів для медіа. В той же час як дрони все активніше входять в звичайне життя та бізнес, кількість модифікації дронів та їх налаштувань зростає, що створює нові виклики для їх використання.
Проблеми користувачів: відсутність стандартизованих навчальних програм для пілотів дронів, що призводить до неоднорідного рівня підготовки, брак централізованої системи для управління тренуваннями та змаганнями, що ускладнює координацію та відслідковування прогресу учасників, відсутність платформи для збору, обробки та аналізу даних про тренування та змагання, що ускладнює оцінку ефективності навчальних програм та виявлення слабких місць у підготовці пілотів.
Існуючі методи навчання та організації змагань з дронами часто є неефективними через відсутність автоматизації процесів, що збільшує витрати часу та ресурсів на підготовку і проведення тренувань, обмежені можливості для відслідковування прогресу пілотів, що ускладнює індивідуальне налаштування навчальних програм під потреби кожного учасника, відсутність систематизованого підходу до аналізу результатів, що призводить до неефективного використання отриманих даних та недосягнення потенціалу пілотів.
Мета та ідея проекту - створити систему, яка автоматизує процес проведення практичних навчань у польових умовах, робить їх більш ефективними та стимулює популяризацію використання дронів у різних сферах життя завдяки систематизованій та ефективній підготовці. Запропонована система забезпечить централізоване управління навчальними програмами та змаганнями, що полегшить координацію та організацію заходів, збір, обробку та аналіз даних про тренування та змагання, що дозволить визначити результативність тренувань, виявити слабкі місця у навчанні та вдосконалити процес підготовки пілотів, створення стандартизованих навчальних програм, що забезпечить однаковий високий рівень підготовки для всіх учасників.
Таким чином, нова система сприятиме більш ефективній та структурованій підготовці пілотів дронів, що дозволить краще використовувати потенціал цих технологій у різних сферах.
1.2 Бізнес-можливості
Для аналізу перспектив в даній предметній області можна розглянути приклади існуючих компаній та їх продуктів, мета та задачі яких перетинаються з метою та завданнями майбутньої програмної системи.
DartDrones та University of Delaware Ground School (США) займаються підготовкою пілотів дронів з націленням на отримання американської сертифікації для пілотів [1]-[2]. Навчання включає теоретичні та практичні заняття з використанням “воріт”, проте не мають автоматизованої системи відслідковування маршруту та проходження “воріт” дроном. Основним недоліком є відсутність автоматизації тренувань та відслідковування результатів, що ускладнює оцінку прогресу пілотів та підвищення ефективності навчальних програм.
На українському ринку схожі організації, такі як Dronarium та UA DRONE SCHOOL, орієнтуються на військове застосування дронів, пропонуючи навчання для військових пілотів [3]-[4]. В основному навчання включає практичні заняття з базовими маневрами. Однак, більшість таких організацій були засновані після початку війни, тому не мають налагоджених процесів навчання та потребують автоматизованої системи. Відсутня система автоматизації відслідковування результатів та прогресу пілотів.
Порівняльний аналіз показує, що DartDrones та University of Delaware Ground School мають переваги у вигляді стандартизованих програм навчання та визнаних сертифікацій, але страждають від відсутності автоматизації тренувань та оцінки результатів. Dronarium та UA DRONE SCHOOL зосереджені на військовому застосуванні дронів, що актуально в умовах війни, але також стикаються з проблемою відсутності автоматизованих систем і браком налагоджених процесів.
Американський ринок представлений великою кількістю схожих компаній, які займаються підготовкою пілотів дронів, в основному для цивільного використання. Основна проблема - відсутність автоматизованих систем для відслідковування та аналізу тренувань.
Український ринок після початку війни поповнився новими організаціями, що займаються підготовкою пілотів для військових цілей. Їхні недоліки включають відсутність автоматизації та систематизації процесів навчання, збору даних та їх аналізу.
Також важливо відзначити, що приклад України показав, що застосування дронів у військовій сфері мають значні перспективи, тому велика кількість країн поступово починають впроваджувати їх використання.
Окремо привабливим є аграрний сектор та сектор промисловості. Аграрний сектор, як в Україні, так і у світі, поступово впроваджує використання дронів. Перспектива створення системи для гнучкого налаштування програм навчання пілотів для специфічних завдань є перспективною.
Запропонована програмна система має на меті автоматизацію процесів тренувань, відслідковування та аналізу результатів, що дозволить підвищити ефективність навчання пілотів дронів у різних сферах. Це сприятиме кращій підготовці пілотів, оптимізації ресурсів та популяризації використання дронів. 
Інтеграція такої системи зі збройними силами різних країн може значно покращити процеси набору та підготовки військових пілотів, забезпечуючи зручний інтерфейс для порівняння статистики та аналізу результатів навчання, про така перспектива потенційно може частково обмежуватися, юридичними аспектами.
1.3 Потреби клієнтів та ринку
Програмний продукт має на меті задовольнити такі основні потреби клієнтів:
Потреба у візуалізації маршруту для тренування, для аналізу його на предмет актуальності та релевантності, відповідно також можливість порівняння маршрутів за складність, та побудови на основі цього якісної та ефективної загальної програми навчання.
Потреба у автоматичному відслідковування коректності проходження тренувального маршруту, вирішення цієї потреби допоможе зробити процес оцінки більш прозорим та зменшити кількість людей необхідну для проведення тренувань.
Потреба в гнучкому налаштуванні тренувального маршруту відповідно до специфіки використання дронів.
Потреба в автоматизації процесу збору та обліку результатів проходження тренування.

2 КОНЦЕПЦІЯ РІШЕННЯ ТА РАМКИ ПЕРВИННОГО ВИПУСКУ

2.1 Окреслення концепції
Концепція програмної системи “Програмна система для автоматизації проведення тренувань та змагань з керування дронами” спрямована на вирішення ключових потреб користувачів, які займаються підготовкою пілотів дронів. Система забезпечує ефективне та швидке проведення навчальних сесій, автоматизацію рутинних завдань, точне відслідковування прогресу учасників та гнучке налаштування тренувальних маршрутів.
Програмна система включає кілька ключових функцій, які забезпечують автоматизацію та підвищення ефективності навчання. Система дозволяє створювати тренувальні маршрути та налаштовувати їх відповідно до потреб конкретної тренувальної сесії. Система надає можливості автоматично відслідковувати проходження маршруту дроном, фіксувати результати та оцінювати точність виконання завдань. Крім того, система надає інструменти для автоматичного оцінювання навичок пілотів на основі їх результатів, що дозволяє швидко виявляти сильні та слабкі сторони учасників. Програмне забезпечення також збирає дані про тренування та змагання, що дозволяє проводити аналіз результатів та вдосконалювати навчальні програми.
Програмна система розроблена для вирішення конкретних потреб користувачів. Вона сприяє підвищенню ефективності навчання завдяки зменшенню часу на проведення тренувань за рахунок автоматизації рутинних завдань. Оптимізація використання ресурсів забезпечується зменшенням потреби у великій кількості інструкторів, що дозволяє знизити витрати на персонал. Завдяки автоматичному відслідковуванню та оцінюванню система забезпечує об'єктивну оцінку прогресу учнів. Можливість швидкого та зручного налаштування тренувальних маршрутів відповідно до індивідуальних потреб учнів підвищує гнучкість навчальних програм.
Впровадження програмної системи в організаціях, що займаються підготовкою пілотів дронів, має низку позитивних ефектів. Завдяки автоматизації процес навчання стає швидшим та ефективнішим, а автоматичне відслідковування маршрутів підвищує точність виконання завдань та оцінювання навичок. Зменшення потреби у великій кількості інструкторів сприяє зниженню витрат на проведення курсів. Це дозволяє знизити ціну за курси, що робить їх доступнішими для ширшої аудиторії.
2.2 Головна функціональність
MF-1: Налаштування маршруту за допомогою графічного інтерфейсу, встановлення порядку проходження етапів маршруту, перегляд та зміна створеного маршруту.
MF-2: Автоматичне відслідковування проходження певної точки маршруту дроном за допомогою датчиків.
MF-3: Відслідковування проходження маршруту певним учасником у реальному часі з відображенням пройдених/непройдених точок маршруту.
MF-4: Збір та обробка даних про проходження маршрутів учасником змагання/тренування або групи учасників, формування статистики, що включає в себе процент успішно та неуспішно пройдених етапів, час проходження маршруту, коефіцієнт успішності відносно інших учасників тренувальної групи.
MF-5: Управління тренувальними групами та сесіями, створення та налаштування тренувальних сесій та груп, додавання учасників до групи, створення тренувальних сесій для груп та управління ними.
MF-6: Управління користувачами, створення нових користувачів в системі, зміна та налаштування їх профіля.
MF-7: Створення резервних копій даних, управління резервними копіями, відновлення даних в разі втрати.
MF-8: Захист користувацьких даних, використання хешування безпечних протоколів взаємодії передачі даних, механізмів авторизації та аутентифікації.
MF-9: Підтримка системою локалізації та інтернаціоналізації для української та англійської мов, підтримка роботи з датою та часом, різними часовими зонами.
2.3 Рамки первинного випуску
В рамках первинного випуску, продукт буде включати реалізацію основної функціональності: створення та налаштування маршруту за допомогою програмної системи, конфігурацію датчиків відповідно до заданого маршруту, відслідковування датчиками проходження маршруту, зберігання інформації про проходження маршруту, відображення даних та їх обробка, також управління користувачами, організаціями та персоналом.
Розподіл функціональностей відповідно до частини системи:
Веб-застосунок: управління користувачами, запрошення нових користувачів та персоналу в систему, видалення, оновлення даних про користувачів, створення організацій, управління організаціями, додавання та управління пристроями організації, створення та управління тренувальними групами, додавання учасників до тренувальних груп, створення та управління тренувальними програмами, побудова маршруту, управління маршрутами, їх оновлення та перегляд, створення тренувальних сесій та управління тренувальними сесіями, створення та управління резервними копіями, адміністрування системи, забезпечення локалізації англійською та українськими мовами, можливість зміни мови застосунку, підтримка різних часових зон та роботу з датою та часом, захист даних та використання безпечних протоколів взаємодії, механізми авторизації та аутентифікації.
Мобільний застосунок: перегляд поточних тренувальних сесій для учасника та інструктора, перегляд інформації про поточну тренувальну сесію її учасниками, проведення тренувальних сесій, початок та завершення тренувальної сесії інструктором, початок та завершення спроб учасників тренувальної сесії інструктором, відслідковування інструктором проходження маршруту конкретним учасником, отримання учасником результатів проходження тренувальної сесії, що включає в себе процент успішно та неуспішно пройдених етапів, час проходження маршруту, коефіцієнт успішності відносно інших учасників тренувальної групи забезпечення локалізації англійською та українськими мовами, можливість зміни мови застосунку, підтримка різних часових зон та роботу з датою та часом, захист даних та використання безпечних протоколів взаємодії, механізми авторизації та аутентифікації.
Серверна частина системи: забезпечення роботи клієнтських функцій з управління користувачами, тренувальними сесіями, програмами та групами та проведення тренувальних сесій. Програма відповідає за отримання та опрацювання даних з пристроїв про проходження етапів тренувальних програм та розрахунок наступних статистичних показників:
Процент успішно пройдених етапів: відношення кількості зафіксованих проходжень етапів до загальної кількості етапів програми.
Процент неуспішно пройдених етапів: відношення кількості етапів для яких не було зафіксовано проходження до загальної кількості етапів.
Час проходження програми учасником: сума часу проходжень окремих етапів програми.
Коефіцієнт успішності учасника: відношення часу проходження програми учасником до медіанного значення часу проходження програми серед учасників групи. 
Також серверна частина забезпечує безпеку та захист даних, використання безпечних протоколів взаємодії, хешування паролів, використання алгоритмів шифрування, використання механізмів авторизації та аутентифікації, безпечне з’єднання зі файловим сховищем резервних копій, створення та управління резервними копіями, функції адміністрування системи. Серверна частина підтримує локалізацію та інтернаціоналізацію для англійської та українських мов, роботу з датами та часом, підтримку різних часових зон.
Частина IoT пристроїв: відслідковування проходження заданої точки маршруту, надсилання даних про успішне або неуспішне проходження даної точки. Конфігурування пристроїв адміністратором з використанням консольного застосунку для подальшого встановлення з’єднання з мережею та підключення до хмарного сервісу для надсилання повідомлень, підтримка локалізації та інтернаціоналізації, робота з датою та часом та відповідне форматування часу проходження етапу маршруту, забезпечення безпеки застосунку, використання безпечного з’єднання при передачі даних по мережі, використання механізмів авторизованого підключення до хмарного сервісу з використанням унікальних ключів, з можливістю їх оновлення, обробка користувацьких даних, що включає в себе вирахування середнього часу проходження етапу за який відповідає пристрій серед учасників групи.

3 ПРОЕКТУВАННЯ, АРХІТЕКТУРА ТА РЕАЛІЗАЦІЯ СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ

3.1 Опис функцій системи
Основною задачею програмної системи в тому числі і серверної частини застосунку є забезпечення автоматизації процесу навчання та проведення змагань з керування дронами. Основними акторами системи є користувач, адміністратор та інструктор, діаграми прецедентів для кожного типу користувачів зображені на рисунках 3.1-3.3.
Рисунок 3.1 - Діаграма прецедентів для типу користувача Адміністратор
Функції адміністратора поділені по категоріям: управління користувачами та адміністрування системи, також адміністратор має функції створення, видалення та управління профілями організацій які використовують дану систему, в тому числі керування набором доступних приладів для кожної організації.
Рисунок 3.2 - Діаграма прецедентів для типу користувача Інструктор
Інструктор в системі має такі основні функції: створення та управління тренувальними групами, додавання нових користувачів до групи, видалення користувачів із групи, створення, редагування та управління тренувальними програмами з використанням пристроїв доступних організації, призначенні певній тренувальній групі сесії з визначеною програмою, інструктор також починає та закінчує тренувальну сесію, відслідковує прогрес проходження тренувальної програми учасниками тренувальної сесії.
Рисунок 3.3 - Діаграма прецедентів для типу користувача Учасник
Функції доступні учаснику включають в себе перегляд тренувальних сесій призначених йому, проходження тренувальних сесій, перегляд результатів вибраної тренувальної сесії.
Основна задача програмної системи має на меті проведення тренувальних сесій. Проведення тренувальної сесії з подальшим переглядом результатів є основним сценарієм використання системи. Для цього адміністратор системи спершу має створити нову організацію та додати до її профіля потрібну кількість пристроїв вказавши їх тип або якщо організація вже створена та її профіль налаштований вибрати існуючу , далі адміністратор додає до організації нового інструктора в разі якщо організація не має інструкторів. Наступним кроком є налаштування процесу тренування для цього інструктор створює тренувальну групу або використовує існуючу, додає до тренувальної групи користувачів, які будуть її учасника, далі інструктор створює програму тренувальної сесії використовуючи доступні пристрої, останнім кроком перед проведенням тренування є створення тренувально сесії, інструктор вибирає групу та програму, встановлює дату та час проведення. Під час проведення тренування інструктор по черзі запускає проходження програми для кожного учасника в групі, фіксуючи його результати після закінчення тренування учасникам і інструктору доступні результати тренувальної сесії, основний сценарій використання програмної системи зображений використовуючи діаграму активностей, діаграму розміщено у додатку А.
3.2 Моделювання предметної області
Перед початком імплементації програмної системи була розроблена модель предметної області. Основні сутностостями в даній системі є організація, інструктор учасник, тренувальна група, тренувальна програма, тренувальна сесія, пристрій, етап тренувальної програми. ER-діаграма зображена на рисунку 3.4.
Рис 3.4 - ER-діаграма предметної області
Між сутностями предметної області визначені такі зв’язки: інструктор належить до організації, одна організація може мати декілька інструкторів, але один інструктор може належати лише до однієї організації, одна організація має багато пристроїв, тренувальна група створюються інструктором, одна тренувальна група може мати одного інструктора, один інструктор може мати декілька тренувальних груп. Тренувальна група складається з учасників, один учасник може входити до декількох тренувальних груп, одна тренувальна група може мати багато учасників. Тренувальна сесія призначена одній тренувальній групі, тренувальна сесія проходить за однією тренувальною програмою. Тренувальна програма складається з багатьох етапів, один пристрій використовується тільки на одному етапі.
3.3 Архітектура системи
Серверну частину програмної системи було розділено на два сервіси, відповідальності яких розмежовані. Кожний з сервісів використовує трирівневу архітектуру та розділений відповідно на три рівні, що відповідають за комунікацію з клієнтами, обробку запитів та надсилання відповіді, бізнес-логіку, доступ до даних. 
Основний сервіс відповідає за створення, редагування, отримання та видалення користувачів системи, тренувальних груп, програм, сесій також авторизацію та аутентифікацію, створення та управління резервними копіями бази даних. Другий сервіс опрацьовує результати тренувальних сесій, приймає дані отримані з пристроїв, зберігає результати, обчислює результати тренувань. 
Дана архітектура та принцип розділення відповідальності сервісів були вибрані для оптимізації роботи програми та розподілення навантаження, розмежування відповідальності обумовлюється отриманням великої кількості інформації з пристроїв, тому логіку опрацювання цих даних було винесено окремо, задля запобіганню перевантаження системи, по схожому принципу сервіс для обробки даних з пристроїв розділений на сервіс для отримання результатів обчислень користувацьких даних, управління тренувальними сесіями та спробами учасників та фонову задачу, що вже безпосередньо обробляє дані з датчиків, щоб розподілити навантаження для операцій читання і запису.
Для обробки даних з пристроїв система використовує асинхронну модель, основану на обробці повідомлень з черги, коли пристрій надсилає повідомлення воно спершу потрапляє в чергу повідомлень, з якої фонова задача порційно вичитує повідомлення та обробляє їх.
Також був використаний архітектурний паттерн CQRS(Command and Query Responsibility Segregation) для рівня доступу до даних [5]. Вибір даного паттерну обумовлений такими його перевагами як розділення операцій читання та створення, оновлення, видалення, що позитивно впливає на ефективність роботи програми.
3.4 Вибір технологій та розгортання системи
Для реалізації системи вибрано технологію .NET Core 8.0 та супутні технології ASP.NET CORE 8.0 та ADO.NET. Для розгортання системи використано хмарну платформу Azure, а саме наступні сервіси: Azure App Service для розгортання частин системи, Azure SQL Database для розгортання баз даних, Azure IoT Hub, Azure Service Bus, Azure Function для обробки даних з пристроїв та Azure Blob Storage для зберігання файлів резервних копій. Основний сервіс використовує формат передачі даних JSON та протокол HTTPS, а комунікація між основним сервісом та сервісом обробки результатів здійснюється за допомогою gRPC, діаграма розгортання зображена на рисунку 3.5. 
Рис 3.5 - Діаграма розгортання системи
Вибір технологій обумовлений різноманітністю представлених конструкцій для розробки, гнучкість налаштування готових компонентів, актуальністю даної версії та довгострокової підтримки даних технологій.
3.5 Фізична модель бази даних
Для зберігання даних була використана база даних SQL Server та технологія ADO.NET для комунікації з базою даних. Фізична модель бази даних відповідає моделі предметної області, також для кожного сервісу використовується окрема база даних. Схеми баз даних наведені на рисунках 3.6-3.7. 
Рис 3.6 - Схема бази даних основного сервісу
Рис 3.7 - Схема бази даних сервісу для опрацювання результатів тренувань
Таблиці були розширені додатковими атрибутами, були додані атрибути унікального ідентифікатора, зв’язки між пов’язаними таблицями реалізуються за допомогою зовнішніх ключів, що забезпечує цілісність даних, бази даних нормалізовані до 3 Нормальної Форми. Для отримання даних використовується мова SQL та API ORM ADO.NET.
Під час проектування системи закладено взаємодію клієнтських та серверної частини через протоколи HTTP/HTTPS, для цього було сформовано REST специфікацію, описану у таблиці 3.1.
Таблия 3.1 - REST специфікація
Шлях до ресурсу
Метод
Опис
/api/backups
POST
Створення нової резервної копії.
/api/backups
GET
Отримання списку усіх резервних копій.
/api/backups/{file_name}
GET
Отримання конкретної резервної копії за ім'ям файлу.
/api/backups/{file_name}
DELETE
Видалення резервної копії за ім'ям файлу.
/api/organizations
POST
Створення нової організації.
/api/organizations/{organization_id}
PUT
Оновлення інформації про організацію.
/api/organizations/{organization_id}
DELETE
Видалення організації за її ідентифікатором.
/api/organizations/{organization_id}/
devices
POST
Додавання нового пристрою до організації.
/api/organizations/{organization_id}/
devices
GET
Отримання списку пристроїв, що належать організації.
/api/organizations/{organization_id}/
devices/{device_id}
PUT
Оновлення інформації про пристрій в організації.
/api/organizations/{organization_id}/
devices/{device_id}
DELETE
Видалення пристрою з організації.
/api/token
POST
Отримання нового токену автентифікації.
/api/training-groups
POST
Створення нової групи навчання.
/api/training-groups/{group_id}
PUT
Оновлення інформації про тренувальну групу.
/api/training-groups/{group_id}
DELETE
Видалення тренувальної групи за її ідентифікатором.
/api/training-groups/{group_id}/
participations
POST
Додавання учасника до групи навчання.
/api/training-groups/{group_id}/
participations/{participant_id}
PUT
Оновлення інформації про учасника групи навчання.
/api/training-groups/{group_id}/
participations/{participant_id}
DELETE
Видалення учасника з групи навчання.
/api/training-programs
POST
Створення нової тренувальної програми.
/api/training-programs/{program_id}
PUT
Оновлення інформації про тренувальну програму.
/api/training-programs/{program_id}
DELETE
Видалення тренувальної програми за її ідентифікатором.
/api/training-sessions
POST
Створення нової сесії навчання.
/api/training-sessions/{session_id}
PUT
Оновлення інформації про сесію навчання.
/api/training-sessions/{session_id}
DELETE
Видалення сесії навчання.
/api/users
POST
Реєстрація нового користувача.
/api/users/{user_id}/training-sessions
GET
Отримання списку навчальних сесій для конкретного користувача.
/api/users/{user_id}/training-sessions/{session_id}/result
GET
Отримання результатів навчальної сесії для конкретного користувача.
3.7 Безпека, захист даних, авторизація та аутентифікація
Система використовує захищену взаємодію з сервером з використанням протоколу HTTPS. У прикладі коду наведеному нижче на строці 7 встановлюється перенаправлення запитів по протоколу HTTP на HTTPS, на строці 5 встановлюється використання протоколу HTTP Strict Transport Security Protocol. 
1   var app = builder.Build();
2  
3   app.UseLocalization();
4  
5   app.UseHsts();
6  
7   app.UseHttpsRedirection();
8  
9   app.UseAuthentication();
10  app.UseAuthorization();
11  
12  app.MapControllers();
13  
14  app.Run();
Дані засоби сприяють безпеці застосунку, перенаправлення по протоколу HTTPS перенаправляє запити по захищеному протоколу, а використання HSTS убезпечує з’єднання під час першого запиту по протоколу HTTP задля попередження можливих атак.
Також для надійного захисту користувацьких даних використовується хешування. У прикладі коду наведеному нижче демонструється хешування паролів користувачів.
1   public string HashPassword(User user, string password)
2   {
3       var salt = RandomNumberGenerator.GetBytes(_saltSize);
4       var hashBytes = Rfc2898DeriveBytes.Pbkdf2(
5           password,
6           salt,
7           _iterations,
8           _hashAlgorithmName,
9           _keySize);
10      var hasStr = Convert.ToBase64String(hashBytes);
11      var saltstr = Convert.ToBase64String(salt);
12      var result = string.Join(
13          _separator,
14          Convert.ToBase64String(hashBytes),
15          Convert.ToBase64String(salt));
16      return result;
17  }
Для хешування використовується алгоритм PBKDF2, що відповідає стандарту Rfc2898 [6].
В застосунку передбачені механізми авторизації та аутентифікації на основі використання JWT-токенів.
1  var jwtToken = new JwtSecurityToken(
2      issuer: _identitySettings.Issuer,
3      claims: claims,
4      expires: DateTime.UtcNow
5        .AddSeconds(_identitySettings.TokenExpiresAfterSeconds),
6      signingCredentials: new SigningCredentials(
7        new SymmetricSecurityKey(
8          Encoding.UTF8.GetBytes(_identitySettings.SecretKey)),
9        SecurityAlgorithms.HmacSha256));
Токени генеруються на основі алгоритму SHA256, використовуючи приватний ключ на стороні серверного застосунку такий підхід захищає від підробки даний токен. Для перевірки токенів використовуються вбудовані засоби ASP.NET для захисту Web API застосунку.
3.8 Адміністрування системи, створення резервних копій, управління користувачами
Одна з функцій передбачених в системі, що стосується її адміністрування це створення резервних копій баз даних. У фрагменті коду наведеному нижче демонструється створення резервної копії.
1   use dronetrainer
2   declare @credentials_count int = (
3     select count(*) 
4     from sys.credentials 
5     where name = @StorageUrl)
6   if @credentials_count = 0 
7       declare @command varchar(max) = 'create credential [' 
8    + @StorageUrl + '] with identity = ''' 
9    + @Identity + ''' , secret = ''' 
10   + @Secret + ''';'
11      exec(@command)
12  ALTER DATABASE dronetrainer
13     SET RECOVERY FULL;
14  declare @timestamp varchar(50) = convert(
15    varchar, getdate(), 126);
16  declare @file_url varchar(100) = concat(
17    StorageUrl, '/', @timestamp, '.bak');
18  BACKUP DATABASE dronetrainer
19     TO URL = @file_url;
20  set @BackupFileName = concat(@timestamp, '.bak');
Для реалізації цього функціоналу застосовувалися SQL SERVER та Azure Blob Storage. У попередньому фрагменті коду використовуються засоби мови SQL та виконуються команди для створення резервних копій, копії зберігаються у хмарному сховищі.
Для забезпечення безпеки під час створення резервних копій та несанкціонованого доступу до хмарного сховища використовується спеціальний токен доступу, на порталі Azure. На рисунку 3.8 зображено зберігання створених резервних копій у хмарному сховищі.
Рис 3.8 Зберігання резервних копій у хмарному сховищі Azure Blob Storage
Наведений нижче блок коду виконує скачування резервних копій, використовуючи API Azure Blob Storage.
1   public async Task<FileStreamResult> 
2     DownloadBackup(string fileName)
3   {
4       var backupContainerClient = _blobServiceClient
5         .GetBlobContainerClient(
6           _backupSettings.ContainerName);
7       var stream = new MemoryStream();
8       var response = await backupContainerClient
9         .GetBlobClient(fileName)
10        .DownloadContentAsync();
11      using (var responseStream 
12          = response.Value.Content.ToStream())
13      {
14          responseStream.CopyTo(stream);
15      }
16      stream.Position = 0;
17      return new FileStreamResult(
18        stream, 
19        response.Value.Details.ContentType);
20  }
Також система підтримує засоби управління користувачами, що включає створення, редагування, перегляд та видалення даних про користувачів, для реалізації даної функціональності використано бібліотеку ASP.NET Core Identity. Прикладу коду програмного застосунку, що відповідаєють за управління користувачами наведені у додатку Б.
3.9 Робота з датами і часом
У застосунку передбачена обробка даних та часу з використанням різних часових зон для користувачів, обробка вхідних значень дати і часу використовуючи зміщення часу для часових зон, використання літнього та зимового часу, конвертація та зберігання дати і часу у форматі UTC,  програма опрацьовує значення дати і часу у форматі ISO [7].
У наведеному нижче фрагменті коду для приймання даних з тіла HTTP запиту використовується структура DateTimeOffset, яка зберігає в собі різницю в часі від UTC, це значення конвертується до UTC.
1  public DateTime Resolve(
2      object source,
3      object destination,
4      DateTimeOffset sourceMember,
5      DateTime destMember,
6      ResolutionContext context) => sourceMember.UtcDateTime;
В застосунку закладена підтримка декількох часових зон, а саме Central Standard Time, Tokyo Standard Time, FLE Standard Time. При створенні користувача вказується його часова зона, згодом при обробці даних з клієнтських застосунків або передачі значень у відповідь, значення дати і часу переводяться до відповідної часової зони. У наведеному нижче прикладі коду продемонстровано частину моделі представлення користувача, яка зберігає в собі його часову зону.
1  [EnumDataType(typeof(SupportedTimeZone))]
2  public SupportedTimeZone UserTimeZone { get; set; }
У наступному фрагменті коду продемонстрировано конвертацію значення дати і часу відповідно до часовою зони користувача.
1   public DateTime 
2     ConvertToSupportedTimeZoneDateTime(
3       DateTime utcDateTime,
4       SupportedTimeZone timeZone)
5   {
6       return TimeZoneInfo
7         .ConvertTimeBySystemTimeZoneId(
8           utcDateTime, 
9           TimeZoneHelper.ToTimeZoneId(timeZone));
10  }
11  
12  public TimeSpan 
13    GetSupportedTimeZoneOffset(
14      SupportedTimeZone timeZone)
15  {
16      return new TimeSpan(
17        TimeZoneHelper
18          .ToTimeZoneOffset(timeZone),
19          0,
20          0);
21  }
В даному фрагменті коду продемонстровано використання структури даних TimeZoneInfo, що знаходить часову зону за її ідентифікатором та конвертує передане значення, використовуючи різницю у часі та інформацію про використання літнього часу та зимового часу.
3.10 Локалізація та інтернаціоналізація
Програмний застосунок підтримує локалізацію та інтернаціоналізацію текстових значень. Для визначення локалю використовується HTTP заголовок Accept-Language, локалі що  підтримуються: американська англійська(en-US) та українська(uk-UA). Для зберігання відповідних текстових значень для кожного локалю використовуються файли ресурсів(рис 3.9-3.10).
Рис 3.9 Файл із ресурсами для англійської локалізації тексту помилок
Рис 3.10 Файл із ресурсами для української локалізації тексту помилок
У наведеному нижче фрагментах коду демонструється логіка визначення локалю та переведення текстового значення до відповідного.
1   app.UseRequestLocalization(options =>
2   {
3       options.DefaultRequestCulture = 
4         new RequestCulture(Locales.EnUS);
5       options.SupportedUICultures = supportedCultures;
6       options.RequestCultureProviders = 
7         [new AcceptLanguageHeaderRequestCultureProvider()];
8       options.ApplyCurrentCultureToResponseHeaders = true;
9   });
10  
11  public string GetLocalizedErrorMessage(
12    string error) => _localizer[error];
3.11 Використання ефективних математичних методів обробки даних
В застосунку реалізовані математичні методи обробки даних результатів тренувань відповідно до бізнес-логіки. Реалізовано наступні математичні розрахунки: розрахунок часу проходження тренування, процент успішно та неуспішо пройдених етапів програми, розрахунок успішності результату проходження тренувальної сесії користувачем відносно результатів інших користувачів у групі.
Час проходження програми розраховується за формулою:
T = nk =1(Tk - T0-k-1m =1Tm) 
де T0 - час початку спроби користувача
     Tk - час проходження конкретного етапу програми
     Tm - час витрачений на проходження точки
Процент успішно пройдених етапів програми розраховується за формулою:
Pусп. = Nусп. / N 
де Nусп. - кількість етапів програми проходження яких зафіксовано
     N - загальна кількість етапів програми
Процент успішно пройдених етапів програми розраховується за формулою:
Pне усп. = (N - Nусп.) / N 
де Nусп. - кількість етапів програми проходження яких зафіксовано
     N - загальна кількість етапів програми
Коефіцієнт успішності результату проходження тренувальної сесії користувачем розраховується за формулою:
K = Tm / T  
де Tm. - медіанне значення часу проходження програми серед учасників групи
     T - час проходження програми користувачем
Приклади фрагментів коду математичних розрахунків наведені в додатку В.
3.12 Використання архітектурних шаблонів
Окрім проектування на рівні загальної архітектури, в застосунку використовувалися архітектурні шаблони та шаблони проектування на рівні окремих частин системи та класів. Були використані такі загальноприйняті шаблони як Model-View-Controller, Inversion of Control(Dependency Injection), CQRS [5], а також шаблони з групи GoF [8]. 
Шаблон MVC використовувався на рівні представлення, де модель була представлена класами предметної області які містили в собі бізнес-логіку та зверталися до бази даних, контроллер зв’язував модель і представлення та відправляв результат у вигляді JSON.
Для передачі залежностей в класи які їх потребують, використовувався шаблон Inversion of Control(Dependency Injection) [9], який полягає в передачі залежностей зовні, використовуючи конструктор класу, попередню зареєструвавши їх в класі контейнері, таким чином зменшується зв’язаність коду, підтримується його модульність та уникається використання неявних залежностей. В фрагменті коду наведеному нижче демонструється реєстрація залежностей та їх використання.
Реєстрація залежностей:
1  services.AddScoped<IAuthService, AuthService>();
2  services.AddScoped<IUserService, UserService>();
3  services
4    .AddScoped<IOrganizationService, OrganizationService>();
5  services
6    .AddScoped<ITraingGroupService, TrainingGroupService>();
7  services
8    .AddScoped<
9      ITrainingProgramService,
10      TrainingProgramService>();
11  services
12    .AddScoped<
13      ITrainingSessionService,
14      TrainingSessionService>();
15  services.AddScoped<IBackupService, BackupService>();
Приклад використання:
1  public sealed class OrganizationController(
2      IOrganizationService organizationService,
3      IMapper mapper,
4      ErrorMessageLocalizer errorMessageLocalizer)
Шаблон Command and Query Responsibility Segregation використовувався для розмежування операцій читання та редагування, видалення, оновлення при зверненні до бази. Таким чином за рахунок розділення операцій підтримується незалежність частин програми та забезпечується масштабованість.
Також був використаний шаблон Builder з групи GoF. Наступний фрагмент коду демонструє використання цього шаблону при конструюванні об’єкту конфігурації програми.
1   var builder = WebApplication.CreateBuilder(args);
2   builder.Services.AddDependencies(
3       builder.Configuration
4         .GetRequiredSection(ConfigurationPaths.JWT),
5       builder
6         .Configuration[ConfigurationPaths.TrainerDB],
7       builder.Configuration
8         .GetSection(ConfigurationPaths.BackupCreate),
9       builder.Configuration
10        .GetSection(ConfigurationPaths.BackupRead));
11  builder.Services.AddResponseLocalization();
12  builder.Services.AddControllers();
13  builder.Services.AddEndpointsApiExplorer();
14  builder.Services.AddSwaggerGen();
15  var app = builder.Build();

4 ПРОЕКТУВАННЯ, АРХІТЕКТУРА ТА РЕАЛІЗАЦІЯ ЧАСТИНИ IoT ЗАСТОСУНКУ СИСТЕМИ

4.1 Опис функцій системи
Функції системи які реалізовані в частині IoT застосунку включають в себе конфігурування пристрою адміністратором системи, початок та завершення тренувальних сесій, початок та завершення спроб учасників інструктором. Також після проходження етапу користувач має можливість бачити результат проходження етапу та середній час проходження етапів після завершення тренувальної сесії. Діаграма прецедентів зображена на рисунку 4.1.
Рисунок 4.1 - Діаграма прецедентів
Використання пристрою передбачає наступні кроки: спершу адміністратор системи конфігурує пристрій, він задає пароль та назву мережі WiFi, для доступу в Інтернет та підключення до хмарного сервісу, вказує унікальний ідентифікатор пристрою та ключ для авторизації з хмарним сервісом, коли пристрій готовий до використання інструктор розпочинає сесію, на цьому етапів пристрій записує ідентифікатор сесії та яку локалізацію використовувати для надсилання відповіді, після цього пристрій переходить в стан незавершеної сесії очікуючи початку спроб учасників. Зміну станів системи проілюстровано на рисунку 4.2.
Рис 4.2 Діаграма станів
Наступним кроком інструктор для кожного учасника запускає проходження програми, пристрій переходить в стан очікування проходження етапу, очікуючи або завершення спроби учасника або інформації про проходження з датчика. В разі якщо датчик зафіксував проходження відповідь надсилається на сервер. Після проходження всіх учасників, інструктор завершує сесію, на отримання повідомлення про закінчення сесії пристрої надсилають середній час проходження свого етапу. 
Діаграму взаємодії консольного застосунку для конфігурації, пристрою та серверної частини розміщено в додатку Г. Порядок виконання дій проілюстровано на діаграмі діяльності розміщеної в додатку Д.
4.2 Конфігурування пристрою
Для конфігурації пристроїв розроблено окремий консольний застосунок, який зчитує введені адміністратором пароль та назву мережі WiFi, унікальний ідентифікатор пристрою та ключ для авторизації у хмарному сервісі. Застосунок записує отриману конфігурацію через USB порт. Нижче наведено фрагмент програмного коду консольного застосунку, який відповідає за запис конфігурації.
1   public bool WriteDeviceConfiguration(
2     DeviceConfiguration configuration)
3   {
4       try
5       {
6           var port = new SerialPort(
7               SerialPortDefaults.Name,
8               SerialPortDefaults.BaudRate,
9               SerialPortDefaults.ParityFlag,
10              SerialPortDefaults.DataBits,
11              SerialPortDefaults.StopBitsFlag)
12          port.Open()
13          var serializedConfig = JsonSerializer
14            .Serialize(configuration)
15          port.Write(serializedConfig)
16          return true;
17      }
18      catch { return false; }
19  }
Пристрій зчитує отриману конфігурацію та зберігає її в пам’ять пристрою. Нижче наведено фрагмент програмного коду, що відповідає за запис отриманої конфігурації.
1   void setDeviceConfiguration(
2     ArduinoJson::JsonDocument & doc) {
3     EEPROM.begin(512);
4     for (int i = 0; i < 160; i++) {
5       EEPROM.write(i, 0);
6     }
7   
8     writeToMemory(0, doc["SSID"]);
9     writeToMemory(32, doc["Password"]);
10    writeToMemory(64, doc["PrimaryKey"]);
11    writeToMemory(128, doc["UniqueId"]);
12  
13    EEPROM.commit();
14    EEPROM.end();
15  }
Зчитування конфігурації з пам’яті пристрою:
1  void loadDeviceConfiguration(){
2    EEPROM.begin(512);
3    ssid = readFromMemory(0, 32);
4    password = readFromMemory(32, 64);
5    device_key = readFromMemory(64, 128);
6    device_id = readFromMemory(128, 160);
7    EEPROM.end();
8  }
4.3 Взаємодія з серверною частиною та обробка повідомлень
При розробці рішення використовувалися плата Arduino Wemos D1 на базі ESP8266 та датчик для зчитування міток MFRC522. Для взаємодії пристрою та серверної частини використовуються протокол MQTT та хмарний сервіс Azure IoT Hub, бібліотека для підключення до хмарного сервісу Azure SDK for C. Наступний фрагмент коду демонструє підключення використовуючи протокол MQTT під час запуску пристрою.
1   static void establishConnection()
2   {
3     connectToWiFi();
4     initializeTime();
5     printCurrentTime();
6     initializeClients();
7   
8     if (generateSasToken(
9       sas_token,
10      sizeofarray(sas_token)) != 0)
11    {
12      Serial.println(
13        "Failed generating MQTT password");
14    }
15    else { connectToAzureIoTHub(); }
16  }
Пристрій та серверна частина та пристрій обмінюються текстовими повідомленнями в форматі JSON. Нижче наведено фрагмент коду що демонструє обробку повідомлень пристроєм на прикладі отримання повідомлення про початок тренувальної сесії.
1  void handle_session_start(
2    ArduinoJson::JsonDocument & message) {
3    is_session_started = true;
4  
5    locale = (String)message["locale"];
6    current_session_id = 
7      ((String)message["session_id"]).toInt();
8  }
Фрагмент коду що демонструє надсилання повідомлень з пристрою наведено у додатку Е. Наступний фрагмент коду демонструє зчитування піднесення мітки.
1   String readRFID() {
2     if (!rfid.PICC_IsNewCardPresent()) {
3       return "";
4     }
5     if (!rfid.PICC_ReadCardSerial()) {
6       return "";
7     }
8     String tag = "";
9     for (int i = 0; i < rfid.uid.size; i++) {
10      tag += rfid.uid.uidByte[i];
11    }
12    rfid.PICC_HaltA();
13    rfid.PCD_StopCrypto1();
14    return tag;
15  }
Дані з пристроїв, які приходять на Azure IoT Hub пересилаються в чергу повідомлень Azure Service Bus. Для опрацювання даних з пристроїв було розроблено окремий сервіс, що розгортається як фонова задача на сервері та періодично зчитує повідомлення з черги, отримавши нове повідомлення визначається тип повідомлення і відповідні дані зберігаються у базу даних. Приклад програмного коду опрацювання сервісом повідомлень з черги наведено у додатку Ж.
4.4 Забезпечення безпеки в застосунку
Для забезпечення безпечного з’єднання з сервером в програмному застосунку були реалізоване використання сертифікатів для встановлення безпечного мережевого з'єднання. Наступний фрагмент демонструє використання сертифікатів та встановлення сертифікату під час встановлення мережевого з'єднання(повний текст сертифікату скорочено).
1   static const char *cert PROGMEM 
2     = R"EOF(
3   -----BEGIN CERTIFICATE-----
4   MIIDfzCCAmegAwIBAgIQCNcp9lsl
5   6mRS3JasHdVeLjANBgkqhkiG9w0BAQsFADAc
6       ...                ...
7   PznlaWdf1dfXMdpSlN36UwOhmmoJQn5Agf
8   WCe7xXTE10VWSludrrPg7sL1qCBcipyHffFShKm+gGs3ElY=
9   -----END CERTIFICATE-----
10  )EOF";
11  static void connectToWiFi()
12  {
13    WiFi.begin(ssid, password);
14    while (WiFi.status() 
15      != WL_CONNECTED) { delay(500); }
16    wifi_client.setTrustAnchors(&cert);
17  }
Також для забезпечення з'єднання по протоколу MQTT, використовувався пароль, що генерується на основі ключа переданого під час конфігурування пристрою адміністратором за допомогою засобів використаної бібліотеки, пароль має термін придатності та періодично оновлюється.
4.5 Локалізація та інтернаціоналізація
В частині IoT застосунку програмної системи реалізована локалізація та інтернаціоналізація: при надсиланні часу проходження етапу, його формат визначається на підставі визначеної локалізації, вибрана локалізація встановлюється під час початку тренувальної сесії, відповідно під час обробки результату серверної частини, час обробляється відповідно до визначеної локалізації і далі зберігається в універсальному форматі. Наступний фрагмент коду демонструє форматування часу проходження етапу перед надсиланням.
1     if(locale == "en-US"){
2       strftime(
3         formatted_pass_time,
4         sizeof(formatted_pass_time),
5         "%F %r",
6         gmtime(&passed_at));
7     } else {
8       strftime(
9         formatted_pass_time,
10        sizeof(formatted_pass_time),
11        "%F %T",
12        gmtime(&passed_at));
13    }
4.6 Обробка даних користувачів з використанням ефективних математичних методів
В частині IoT застосунку програмної системи реалізована наступна бізнес-логіка та математичні методи обробки даних: вирахування середнього значення часу проходження певного етапу програми в секундах. У наступному фрагменті коду демонструється вирахування середньго значення часу проходження етапу програм учасниками.
1   void handle_session_end() {
2     double step_avarage_time = 0;
3   
4     for(int i = 0; i < gate_pass_results.size(); i++){
5       double attempt_avarage = gate_pass_results[i] 
6         / (double)gate_pass_results.size();
7       step_avarage_time += attempt_avarage;
8     }
9   
10    is_session_started = false;
11    gate_pass_results.clear();
12  }
Для цього під час початку спроби учасника пристрій приймає дату і час початку спроби, зберігає її, під час того як пристрій зафіксував проходження етапу, від часу початку спроби віднімається час проходження етапу та зберігається у пристрої, після отримання повідомлення про завершення тренувальної сесії, пристрій вираховує середнє значення часу проходжень та відправляє на сервер.

5 ПРОЕКТУВАННЯ, АРХІТЕКТУРА ТА РЕАЛІЗАЦІЯ КЛІЄНТСЬКОЇ ЧАСТИНИ СИСТЕМИ

5.1 Опис функцій системи
Клієнтська частина програмної системи включає в себе функції адмініструванн та управління процесом навчання інструкторами. Функції адміністрування системи доступні лише системним адміністраторам та включають в себе управління та створення резервних копій баз даних, управління та додавання нових користувачів у систему, створення на управління організаціями, що використовують дану систему, а також управління та реєстрація нових пристроїв цих організацій у системі.
Діаграму прецедентів для типу користувача Адміністратор зображено на рисунку 5.1.
Рис - 5.1 Діаграма прецедентів для типу користувача Адміністратор
Також до клієнтської частини програмної системи мають доступ інструктори. Діаграму прецедентів для типу користувача Інструктор зображено на рисунку 5.2.
Рис 5.2 - Діаграма прецедентів для типу користувача Інструктор
Функції доступні інструкторам включають в себе створення та управління тренувальними групами та програмами, створення тренувальних програм з використанням пристроїв, що відведені організації до якої належить інструктор, додавання нових учасників до групи, створення та управління тренувальними сесіями для відповідної групи.
Для виконання основної задачі системи, а саме проведення тренувань адміністратор та інструктор мають виконати відповідні підготовчі дії. Відповідно до функцій передбачених у системі, адміністратор спочатку створюює профіль організації у системі та додає її пристрої, а також додає нового інструктора до організації. Порядок виконання цих дій для типу користувача Адміністратор зображений на рисунку 5.3.
Рис - 5.3 Діаграма активності для типу користувача Адміністратор
Після того, як інструктор був доданий, він має можливість увійти в систему та розпочати підготовчі дії для проведення тренувальних сесій. Порядок виконання цих дій для типу користувача Інструктор зображений на рисунку 5.4.
Рис - 5.4 Діаграма активності для типу користувача Інструктор
В першу чергу інструктор строює тренувальну програму, використовуючи пристрої організації, наступним кроком він створює тренувальну групу та додає до неї учасників, після цього для відповідної тренувальної групи створюється тренувальна сесія, з визначеною програмою та часом проведення.
5.2 Архітектура системи
Під час проектування клієнтського застосунку використано дворівневу архітектуру. Перш за все увесь програмний код застосунку фізично було розбито на окремі незалежні модулі, в яких відокремлено програмний код та логіку, характерну для певної функціональності системи. Логічно кожний з модулів відноситься до одного з рівнів: рівень представлення або рівень доступу до даних, який використовуючи HTTP-клієнт надсилає відповідні запити до серверної частини. На рисунку 5.5 зображено діаграму компонентів клієнтської частини застосунку.
Рис 5.5 - Діаграма компонентів
На рівні представлення знаходяться модулі, що містять в собі та файли розмітки та класи, що відповідають на оновлення представлень, реагування та користувацький ввід, обробку подій. Кожна сторінка представлення складається з одного такого класу та файлу розмітки. На рисунку 5.6 зображена структура такої сторінки на прикладі сторінки для відображення списку резервних копій.
Рис 5.6 - Приклад структури модулів рівня представлення
Кожна така сторінка використовує шаблон MVVM [10], файл з розширенням .ts, відповідає Моделі представлення, та повідомляє представлення про оновлення стану, а також реагує на оновлення представлення і комунікує з моделлю, якої в даному випадку виступають класи доступу до даних через HTTP-клієнт, таким чином зберігається розділення відповідальності і представлення не комунікує з моделлю на пряму. Нижче наведено приклад фрагментів програмного коду, що демонструє дану взаємодію. У першому фрагменті модель представлення використовує інтерфейс, що надає компонент доступу до даних отримує список резервних копій та оновлює відповідне поле.
1  loadBackups(): void {
2    this.backupApiService.listBackups().subscribe(
3      (backups) => {
4        this.backups = backups;
5      }
6    );
7  }
У наступному прикладі представлення підписується на оновлення даного поля та оновлює його після отримання повідомлення.
1   <tr *ngFor="let backup of backups">
2     <td>{{ backup.id }}</td>
3     <td>{{ backup.fileName }}</td>
4     <td>
5       <button class="btn btn-primary">
6       <a
7       class="link-light link-underline-opacity-0"
8       [href]="getDownloadBackupLink(backup.fileName)">
9       {{ "maintenance.backups.table.download" | translate }}
10      </a>
11      </button>
12    </td>
13  </tr>
У наступному фрагментах програмного коду демострується повідомлення представленням моделі представлення про зміни та реагування моделі представлення, а також повідомлення моделлю представлення моделі про необхідність оновлення стану.
Повідомлення представленням моделі представлення через виклик методу:
1  <h2>{{ "maintenance.backups.title" | translate }}</h2>
2  <button class="btn" (click)="createBackup()">
3    {{ "maintenance.backups.createButton" | translate }}
4  </button>
Реагування моделі представлення та повідомлення моделі:
1  createBackup(): void {
2    this.backupApiService.createBackup().subscribe(
3      () => {
4        this.loadBackups();
5      });}
Структура клієнтської частин додатку, розділення програмного коду на модулі та взаємодія між ними зображені на діаграмі пакетів(див. рис. 5.7).
Рис 5.7 Діагарама пакетів
Пакетом, що інкапсулює в собі взаємодію з серверною частиною виступає пакет під назвою CoreModule, від надає назовні інтерфейси які містять методи, оновлення, додавання, видалення, отримання даних,  а також в ньому знаходяться класи моделей запитів та відповідей, що приходять з серверу або надсилаються на сервер. У наступному фрагменті коду продемонстровано надсилання запиту за допомогою HTTP-клієнта.
1   addOrganizationDevice(
2     organizationId: number,
3     deviceCreateVM: OrganizationDeviceCreateVM
4   ): Observable<any> {
5     return this.http.post(
6       `${this.apiUrl}/
7       ${this.organizationsEndpoint}/
8       ${organizationId}/devices`,
9       deviceCreateVM
10    );
11  }
Таким чином дана функціональність не виноситься за межі модуля та цей модуль логічно відноситься до рівня доступу до даних.
5.3 Безпека та захист даних
В клієнтському застосунку програмної системи відповідно до вимог використовуються механізми авторизації аутентифікації, використання безпечних протоколів передачі даних HTTPS, обмеження доступу до функцій системи відповідно до ролі користувача.
Механізми аутентифікації передбачають використання використання JWT токенів для отримання доступу до системи під час входу, генерація яких відбувається на стороні серверної частини за допомогою унікального приватного ключа.
Токен також містить в собі інформацію про роль користувача, на стороні клієнтського застосунку відповідно до ролі користувачу надається доступ до певних функцій системи, наприклад функції адміністрування: управління організаціями, користувачами та резервними копіями доступні лише користувачам з роллю Адміністратор.
5.4 Локалізація та інтернаціоналізація
В системі передбачена підтримка локалізації для англійської та української мов. Переклади текстів зберігаються у файлах ресурсів, користувач має змогу динамічно змінювати мову застосунку. У нижче наведених прикладах програмного коду продемонстровано, зберігання перекладів та локалізація текстів у представленнях.
Фрагмент файлу з ресурсами:
1   "trainingGroups": {
2     "title": "Тренувальні групи",
3     "createButton": "Створити тренувальну групу",
4     "table": {
5       "id": "Унікальний номер",
6       "name": "Назва",
7       "organization": "Організація",
8       "view": "Переглянути"
9     }
10  }
Локалізація текстів в представлені:
1  <h2>{{ "maintenance.backups.title" | translate }}</h2>
2  <button class="btn" (click)="createBackup()">
3    {{ "maintenance.backups.createButton" | translate }}
4  </button>
Для підтримки локалізації була використана бібліотека npx-translate.
5.5 Вибір технологій та графічний інтерфейс системи
На рисунках 5.8 - 5.9 наведені приклади графічного інтерфейсу клієнтської частини застосунку.
Рисунок 5.8 - Сторінка для перегляду всіх тренувальних сесій
Рисунок 5.9 - Створення тренувальної групи
Для реалізації клієнтського застосунку були використані HTML, CSS, TypeScript, бібліотеки Angular 13, Angular Material та Bootstrap. Сторінки клієнтської частини використовують різноманітні елементи управління, такі як таблиці, модальні вікна для зручного представлення відповідної інформації.

6 ПРОЕКТУВАННЯ, АРХІТЕКТУРА ТА РЕАЛІЗАЦІЯ ЧАСТИНИ МОБІЛЬНОГО ЗАСТОСУНКУ

6.1 Опис функцій системи
Мобільний застосунок розроблений для використання двома типами користувачів: учасник тренувань та інструктор. Функції закладені для цієї частини системи включають в себе, безпосереднє проведення тренувань інструктором та отримання результатів учасником. Діаграма прецедентів зображена на малюнку 6.1.
Рис 6.1 - Діаграма прецедентів
Учасник тренувальної сесії та інструктор мають можливість входу в систему. Учаснику тренувальних сесій також доступні наступні функції: перегляд запланованих для його групи тренувальних сесій та перегляд результатів тренувальних сесій. Інструктору доступні наступні функції: початок та завершення тренувальних сесій, а також початок та завершення спроб учасників даної сесії. На рисунку 6.2 зображено діаграму діяльності, де відображено порядок виконання дій для проведення тренувальної сесії з використанням мобільного застосунку.
Рис 6.2 Діаграма діяльності
Проведення тренувальної сесії з подальшим переглядом результатів є основним сценарієм використання системи. Під час проведення тренування інструктор по черзі запускає проходження програми для кожного учасника в групі, фіксуючи його результати після закінчення тренування учасникам доступні результати тренувальної сесії.
6.2 Архітектура
При проектуванні мобільного застосунку використовувалася дворівнева архітектура, рівні якої фізично розділені на окремі проекти і відповідають рівню представлення та рівню доступу до даних. Діаграма компонентів зображена на рисунку 6.3.
Рис 6.3 - Діаграма компонентів
Перший рівень представлення відповідає за відображення компонентів, оновлення представлень, застосування локалізації до текстів представлень. Другий рівень доступу до даних відповідає за надсилання запитів до серверної частини, обробку цих даних, надає механізми авторизації та аутентифікації. На рисунку 6.4 зображено діаграму пакетів мобільного застосунку.
Рис 6.4 - Діаграма пакетів
Рівень доступу до даних комунікує з серверною частиною використовуючи протоколи HTTPS, з використанням HTTP-клієнту для отримання даних з основного сервісу, наприклад отримання списку тренувальних сесій, авторизації, тощо та викликаючи віддалені процедури по протоколу GRPC на сервісі для обробки даних тренувальних сесій та управління тренувальними сесіями, наприклад отримання результатів сесії, її початок та завершення, початок та завершення спроби учасника, цей сервіс в свою чергу надсилає повідомлення пристрою використовуючи протокол MQTT. Також в окремий пакет винесено моделі запиту та відповіді та спільні класи такі як константи, для зменшення дублювання коду на різних рівнях.
6.3 Реалізація рівня представлення
Для написання мобільного застосунку використовувалася бібліотека .NET MAUI. На рівні представлення знаходяться сторінки застосунку кожна з яких складається з класу С# та XML файлу розмітки. Кожна така сторінка використовує шаблон MVVM [10], файл з класом C#, відповідає Моделі представлення, та повідомляє представлення про оновлення стану, а також реагує на оновлення представлення і комунікує з моделлю, якої в даному випадку виступають класи доступу до даних через HTTP та GRPC клієнти, таким чином зберігається розділення відповідальності і представлення не комунікує з моделлю на пряму. Нижче наведено приклад фрагментів програмного коду, що демонструє дану взаємодію.
Представлення комунікує з моделлю представлення через підписку на подію:
1   <VerticalStackLayout>
2     <Entry 
3       Placeholder="{
4       Binding LocalizationResourseManager
5       [LoginPasswordPlaceholder]}" 
6       TextChanged="OnUserNameEntered"/>
7     <Entry Placeholder="{
8       Binding LocalizationResourseManager
9       [LoginUserNamePlaceholder]}"
10      IsPassword="True"
11      TextChanged="OnPasswordEntered"/>
12    <Button Text="{
13      Binding
14      LocalizationResourseManager
15      [LoginSignInButton]}"
16      Clicked="OnLogin"/>
17  </VerticalStackLayout>
Обробка подій моделлю представлення:
1   public async void OnLogin(
2     object sender,
3     EventArgs eventArgs)
4   {
5     await _authService
6       .Authorize(_userName, _password)
7     if (_authService.IsLoggedIn())
8     {
9         await Shell.Current
10        .GoToAsync("//home");
11    }
12  }
6.4 Безпека та захист даних
В мобільному застосунку програмної системи відповідно до вимог використовуються механізми авторизації аутентифікації, використання безпечних протоколів передачі даних HTTPS, обмеження доступу до функцій системи відповідно до ролі користувача.
Механізми аутентифікації передбачають використання використання JWT токенів для отримання доступу до системи під час входу, генерація яких відбувається на стороні серверної частини за допомогою унікального приватного ключа.
Токен також містить в собі інформацію про роль користувача, на стороні мобільного застосунку відповідно до ролі користувачу надається доступ до певних функцій системи.
6.5 Локалізація та інтернаціоналізація
В системі передбачена підтримка локалізації для англійської та української мов. Переклади текстів зберігаються у файлах ресурсів, користувач має змогу динамічно змінювати мову застосунку. У нижче наведених прикладах програмного коду продемонстровано, зберігання перекладів та локалізація текстів у представленнях. Також у застосунку відповідно до часової зони користувача змінюється час сесій.
Рис 6.5 Файл ресурсів
Оновлення текстів представлення використовуючи локалізацію:
1  _isActiveAttempt = !_isActiveAttempt;
2  ((Button)sender).Text = 
3    LocalizationResourseManager["SessionEndAttempt"]
4    .ToString();
5  ((Button)sender).BackgroundColor = 
6    Color.FromArgb("#f76565");
7  var clickedButtonId = ((Button)sender).Id;
6.6 Бізнес-логіка
Мобільний застосунок має наступну бізнес-логіку та обробку користувацьких даних, а саме отримання результатів тренувальних сесій для користувача, де вираховується коефіцієнт успішності, час проходження, процент успішно та неуспішно пройдених етапів програми. У нижче наведеному прикладі програмного коду демонструється отримання даних про результати тренувальної сесії.
1   public async 
2     Task<UserTrainingSessionResult> 
3     GetUserTrainingSessionResult(
4       int userId,
5       int sessionId)
6   {
7       var userSessionResult = await 
8         _trainingResultClient
9         .GetUserTrainingResultAsync(
10          new UserTrainingResultRequest()
11      {
12          UserId = userId,
13          SessionId = sessionId
14      })
15      return _mapper
16        .Map<UserTrainingSessionResult>(
17          userSessionResult);
18  }

ВИСНОВКИ

Метою та ідеєю роботи було створити програмну систему, яка автоматизує процес проведення практичних навчань в польових умовах, робить їх більш ефективними та стимулює популяризацію використання дронів у різних сферах життя за рахунок систематизованої та ефективної підготовки. 
Під час розробки було проведено бізнес-аналіз предметної області та порівняльний аналіз конкурентів, сформовано основні критерії до програмної системи і визначено головні проблеми користувачів. На основі цього було розроблено програмну систему, що складається з декількох частин: серверної частини, клієнтського застосунку, IoT пристрою та мобільного додатку. Визначено архітектуру її складових, яку задокументовано за допомогою відповідних UML діаграм.
Особлива увага приділялася вимогам щодо забезпечення безпеки користувацьких даних, використанню безпечних протоколів взаємодії, механізмів авторизації та аутентифікації, забезпеченню функцій адміністрування, створенню резервних копій, забезпеченню локалізації та інтернаціоналізації, роботі з датами та часом, а також використанню ефективних методів обробки користувацьких даних. 
Таким чином, запропонована програмна система значно покращить процес навчання пілотів дронів, зробить його ефективнішим та доступнішим, сприятиме розвитку цієї сфери та задоволенню потреб користувачів.
Результат роботи у вигляді програмного коду розміщено за посиланням [11], відеозапис тестування системи розміщено за посиланням [12], результати перевірки на плагіат розміщено у додатку И.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАНЬ

Сайт організації DartDrones URL: https://www.dartdrones.com (дата звернення: 18.03.2024)
Сайт організації University of Delaware Ground School URL: https://groundschool.com (дата звернення: 18.03.2024)
Сайт організації Dronarium URL: https://dronarium.academy (дата звернення: 18.03.2024)
Сайт організації UA DRONE SCHOOL URL: https://uadroneschool.com (дата звернення: 18.03.2024)
Опис шаблону CQRS URL: https://uk.wikipedia.org/wiki/CQRS (дата звернення: 10.04.2024)
Опис алгоритму PBKDF2 URL: https://uk.wikipedia.org/wiki/PBKDF2 (дата звернення: 15.04.2024)
Опис стандарту представлення дати та часу ISO 8601 URL: https://uk.wikipedia.org/wiki/ISO_8601 (дата звернення: 15.04.2024)
Gamma, E., Helm, R., Johnson, R., Vlissides, J. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994. 395 p. (дата звернення: 15.04.2024)
Опис шаблону IoC URL: http://www.laputan.org/drc/drc.html (дата звернення: 16.04.2024)
Опис шаблону MVVM URL: https://en.wikipedia.org/wiki/Mode-view-viewmodel (дата звернення: 07.05.2024)
Посилання на програмний код застосунку: https://github.com/NureShramkoIvan/apzkr-pzpi-21-5-shramko-ivan
Посилання на відеозапис тестування: https://youtu.be/E-xE-mUAkiM

ДОДАТОК A

Рис 1.1 - Діаграма активності

ДОДАТОК Б

Створення користувача:
1   public async Task<IdentityResult> 
2     DeleteAsync(
3       User user,
4       CancellationToken cancellationToken)
5   {
6       await _mediator.Send(
7         new UserDeleteCommand(user.Id));
8       return IdentityResult.Success;
9       return IdentityResult.Failed(
10        new IdentityError 
11        {
12          Description = ex.Message
13        });
14  }
Видалення користувача:
1    public async Task<IdentityResult> 
2      DeleteAsync(
3        User user,
4        CancellationToken cancellationToken)
5    {
6        await _mediator.Send(
7          new UserDeleteCommand(user.Id));
8        return IdentityResult.Success;
9        return IdentityResult.Failed(
10        new IdentityError 
11        {
12          Description = ex.Message
13        });
14  }
Оновлення даних користувача:
1   public async Task<IdentityResult> 
2     UpdateAsync(
3       User user,
4       CancellationToken cancellationToken)
5   {
6       await _mediator.Send(new UserUpdateCommand(
7           user.Id,
8           user.UserName,
9           user.NormalizedUserName,
10          user.Password));
11      return IdentityResult.Success;
12      return IdentityResult.Failed(
13        new IdentityError 
14        { 
15          Description = ex.Message
16        });
17  }

ДОДАТОК В

Розрахунок успішно та не успішно пройдених точок:
1  var successfullGatesPercent = 
2    userSessionAttemptSteps
3      .Where(r => r.PassedAt is not null).Count() 
4    / userSessionAttemptSteps.Count();
5  
6  var unsuccesfullGatesPercent = 
7    userSessionAttemptSteps
8      .Where(r => r.PassedAt is null).Count() 
9    / userSessionAttemptSteps.Count();
Розрахунок часу проходження тренування:
1   var selectedUserSessionCompletionTime = 
2     userSessionAttemptSteps.Aggregate(
3       TimeSpan.Zero,
4       (acc, item) =>
5       {
6           acc += item.PassedAt is not null
7               ? item.PassedAt.Value 
8                 - selectedUserSessionAttempt
9                   .StartedAt.Value 
10                - acc
11              : TimeSpan.Zero;
12          return acc;
13      });
Розрахунок коефіцієнту успішності користувача:
1  var selectedUserSessionCompletionTime = 
2    selectedUserSessionCompletionTime 
3    + (selectedUserSessionCompletionTime 
4      / successfullGatesPercent 
5      / userSessionAttemptSteps.Count() 
6      * unsuccesfullGatesPercent);
7  
8  var successIndex = median 
9    / selectedUserSessionCompletionTime;

ДОДАТОК Г

Рис 1.1 - Діаграма взаємодії системи

ДОДАТОК Д

Рис 1.1 - Діаграма діяльності

ДОДАТОК E

Фрагменти коду надсилання повідомлень від пристрою на прикладі надсилання інформації про середній час проходження етапу:
1   void handle_session_end() {
2     if(!is_session_started) {
3       return;
4     }
5     double step_avarage_time = 0;
6   
7     for(int i = 0; i < gate_pass_results.size(); i++){
8       double attempt_avarage = 
9         gate_pass_results[i] 
10        / (double)gate_pass_results.size();
11      step_avarage_time += attempt_avarage;
12    }
13    is_session_started = false;
14    gate_pass_results.clear();
15    String message = 
16      "{\"message_type\": \"session_result\", \"session_id\": " 
17      + String(current_session_id)
18      + ", \"device_id\" : \"" 
19      + String(device_id) + "\", \"avarage_time_in_seconds\": "
20      + String(step_avarage_time) +" }";
21    sendTelemetry(message.c_str());
22  }

ДОДАТОК Ж

Фрагменти коду, що демонструють зчитування повідомлень з черги та їх подальше опрацювання:
1   public async Task ProcessAsync(
2     CancellationToken cancellationToken)
3   {
4     while (!cancellationToken
5       .IsCancellationRequested)
6     {
7       var telemetryMessages = await _queueService
8         .ReadMessages();
9       foreach (var message in telemetryMessages)
10      {
11        var messageJson = 
12          JsonDocument.Parse(message.Body.ToString());
13        var canGetType = messageJson
14          .RootElement.TryGetProperty(
15            "message_type", out var messageType);
16        if (canGetType)
17        {
18            await ProcessTelemetryMessage(
19              messageType.GetString(),
20              messageJson);
21        }
22        await _queueService.CompleteMessage(message);
23      }
24    }
25  }

ДОДАТОК И

Рис 1.1 - Результати перевірки роботи на антиплагіат